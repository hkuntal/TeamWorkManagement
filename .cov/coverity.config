<?xml version="1.0" encoding="utf-8"?>
<Coverity.Prevent.Desktop.Configuration>
  <Version>7.0.3</Version>
  <DataBase>
    <UseSSL>false</UseSSL>
    <SavePassword>true</SavePassword>
    <RemoteDbLocation />
    <RemoteDbPort>8080</RemoteDbPort>
    <UserName />
    <UserPassword />
  </DataBase>
  <CentralAnalysisProject>
    <Streams />
  </CentralAnalysisProject>
  <DefectsFoundBy>
    <DefectsSource>LocalOnly</DefectsSource>
    <LastFoundBy />
    <DefectSourceStream />
    <DefectSourceLanguage />
  </DefectsFoundBy>
  <AnalysisBuildSettings>
    <BuildConfig>
      <BuildWithInstrument>false</BuildWithInstrument>
      <ContinueAnalysisAfterBuildFail>false</ContinueAnalysisAfterBuildFail>
      <BuildOptions />
      <PostBuild />
      <BuildEngine>
        <Name>MSBuild 4.0</Name>
        <BinaryPath>C:\Windows\Microsoft.NET\Framework\v4.0.30319\\MSBuild.exe</BinaryPath>
      </BuildEngine>
    </BuildConfig>
    <AnalysisOptions />
    <PostAnalyze />
    <CommitOptions />
    <PostCommit />
    <UseSolutionCheckers>false</UseSolutionCheckers>
    <ImportMicrosoftCodeAnalysis>false</ImportMicrosoftCodeAnalysis>
    <CheckersOverridenFirstTime>false</CheckersOverridenFirstTime>
    <Checkers>
      <Checker>
        <Name>ALLOC_FREE_MISMATCH</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ARRAY_VS_SINGLETON</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>stat_cutoff</Name>
            <Type>int</Type>
            <Description>This option sets the value used by statistical analysis to filter defects. If a singleton pointer is passed to a function, but there are at least this many total call sites in the code base where the address of something is passed to that same function (in the same argument position), then no defect is reported.

Reducing this value will cause more defects to be reported, and usually more of them will be false positives.

The default value is 10.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ASSERT_SIDE_EFFECT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>distrust_functions</Name>
            <Type>bool</Type>
            <Description>When this option is set to true, the checker will regard any function call as potentially having a side effect.  Consequently, any use of a recognized assert macro with a function call in its condition will be reported as a defect.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>macro_name_has</Name>
            <Type>regex</Type>
            <Description>This option expands the set of recognized assert macros using a regular expression (Perl syntax).

The default value is "[Aa]ssert|ASSERT".</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>macro_name_lacks</Name>
            <Type>regex</Type>
            <Description>This option restricts the set of recognized assert macros.  Any macro name that matches the specified regular expression (Perl syntax) will not be treated as an assert macro, even if it is one of the names recognized by default or a regular expression specified with macro_name_has.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ASSIGN_NOT_RETURNING_STAR_THIS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>rule (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ATOMICITY</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>concurrency (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_ALLOC_ARITHMETIC</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_ALLOC_STRLEN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_plus_any</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report strlen(p+C) for any constant C, not just 1.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_COMPARE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_EQ</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>stat_bias</Name>
            <Type>float</Type>
            <Description>Specifies a floating point number N that is used by the checker to report a defect when (S + N) / (S + R) &lt;= T. Here, S = number of structural comparisons, R = number of referential comparisons, and T = value of the stat_threshold option value. This option  is automatically set to 0.5 when cov-analyze --agressiveness-level high. Default value of stat_bias is 0.25.</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>stat_threshold</Name>
            <Type>float</Type>
            <Description>Reports referential equality comparisons as defects when the specified threshold of structural equality comparisons (a percentage of all equality comparisons) is met or exceeded. For example, -co BAD_EQ:stat_threshold:50 will cause the checker to report a defect on all referential equality comparisons if 50% of the comparisons are structural. This option  is automatically set to 70 when cov-analyze --agressiveness-level medium. Default value is 80.</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_EQ_TYPES</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_FREE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_first_field</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will not report freeing of the address of the first field of a structure, or the first element of the first field, etc.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_OVERRIDE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>virtual</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report cases in C++ where a method in a derived class has the same signature as a base class method, but the base class method is not virtual, and therefore not overridden (it is merely hidden).  That is suspicious, but may be intentional.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_SHIFT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_SIZEOF</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_pointers</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report when sizeof is used to obtain the size of almost any pointer.  (A few cases are not reported because they are essentially always safe.)

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BUFFER_SIZE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_fixed_size_dest</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports defects when the  destination size is known, but the source size is not. These are  potential overflows because the source could be arbitrarily large and  should be length checked before being passed to the copy routine. 

When this option is false, defects are not reported unless both source  and destination sizes are known.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CALL_SUPER</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_empty_overrides</Name>
            <Type>bool</Type>
            <Description>When false (default for C#), the checker will not report a defect on a method with an empty implementation (as in { }) because the developer might have intended that the method not call super.

 When true (default for Java), empty methods are are treated like non-empty methods are treated. This is a C# and Java option. It is automatically set to true (enabled) for C# and Java when cov-analyze --agressiveness-level medium.</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>threshold</Name>
            <Type>float</Type>
            <Description>This option sets the minimum fraction of method overriders that must call the superclass implementation in order for the checker to conclude that all overriders must do so.

The default value is 0.65. This is a C# and Java option.</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>whitelist</Name>
            <Type>bool</Type>
            <Description>This option sets whether CALL_SUPER uses its built-in list of methods whose superclass implementation  just be called from overriders.

 For Java, this list consists of "clone," "finalize," and a number of  Android API methods.  If true (the default), any overrider of a whitelisted methods is expected to call the super implementation, regardless of statistical evidence.  This is a C# and Java option. </Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CHAR_IO</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CHECKED_RETURN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>error_on_use</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will regard passing the return value of one function to the parameter of another, without first checking that value, as a defect (if it concludes that the first function's return value is supposed to be checked).

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>stat_threshold</Name>
            <Type>float</Type>
            <Description>This option sets the percentage of call sites to a function that must check the return value in order for the statistical analysis to conclude that all call sites should be checked.

The default value is 80. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CHROOT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.ADDROF_LEAK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_ccomptr</Name>
            <Type>bool</Type>
            <Description>When set to true, enabled leaks on CComPtr objects are reported. This option is disabled by default.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.BAD_FREE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.BSTR.ALLOC</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.BSTR.BAD_COMPARE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>arith_yields_wchar_t</Name>
            <Type>bool</Type>
            <Description>When this option is true, any expression &lt;b&gt;+&lt;i&gt; for BSTR &lt;b&gt; and  integer &lt;i&gt; is assumed to have the type wchar_t* (instead of BSTR), which means the checker will report fewer defects.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.BSTR.CONV</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_bstr_arith</Name>
            <Type>bool</Type>
            <Description>When this option is true, arithmetic on a BSTR expression is assumed to  produce a result of type wchar_t* (rather than BSTR), which means the  checker will report more defects.  The additional defects might be  considered false positives if the resulting pointer is only used in very  limited ways, but it is still questionable practice.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.BSTR.NE_NON_BSTR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>arith_yields_wchar_t</Name>
            <Type>bool</Type>
            <Description>When this option is true, any expression &lt;b&gt;+&lt;i&gt; for BSTR &lt;b&gt; and  integer &lt;i&gt; is assumed to have the type wchar_t*, instead of BSTR.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CONSTANT_EXPRESSION_RESULT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_bit_and_with_zero</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report bitwise AND (&amp;) of expressions with 0 as defects.

The default value is false for C/C++ but true for C# and Java.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_bit_and_with_zero_in_macros</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report bitwise AND of expressions with 0 as defects, even if they occur entirely within macro expansions.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_constant_logical_operands</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report constructs where, in a logical AND (&amp;&amp;) or logical OR (||) context, one of the operands is a constant expression constructed using bitwise AND (&amp;) and bitwise OR (|).

The default value is false for C/C++ but true for C# and Java.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_constant_logical_operands_in_macros</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report the same kind of problems found by the report_constant_logical_operands option, even if they occur entirely within macro expansions.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_unnecessary_op_assign</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report &amp;= or |= operations that assign a constant value and thus can be replaced with a simple assignment.

The default value is false for C/C++, Java, and C#.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COPY_PASTE_ERROR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COPY_WITHOUT_ASSIGN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>rule (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CTOR_DTOR_LEAK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DEADCODE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>no_dead_default</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will not report defects caused by an unreachable default statement in a switch-case statement.

The default value is false for C/C++, Java, and C#.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_redundant_tests</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report cases where a branch cannot be taken, if that does not result in any fragment of code being unreachable.

The default value is false for C/C++, Java, and C#.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DELETE_ARRAY</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>no_error_on_scalar</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker does not report defects when the array element type is a scalar (e.g., int).  Although it is incorrect, using 'delete' on an array of scalars is harmless in many implementations of C++, so this option is provided to suppress reporting that.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DELETE_VOID</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DIVIDE_BY_ZERO</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ENUM_AS_BOOLEAN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>EVALUATION_ORDER</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>FORWARD_NULL</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name />
            <Value />
            <Languages />
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
          <string>DEFAULT</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>GUARDED_BY_VIOLATION</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>lock_inference_threshold</Name>
            <Type>float</Type>
            <Description>This option specifies the minimum percentage of accesses to a variable or field that must be protected by a particular lock in order for the checker to conclude that the variable or field should always be protected by that lock.

For C#, the default value is 75.

For Java, the default value is 70.</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>INCOMPATIBLE_CAST</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>INFINITE_LOOP</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_asm</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will treat inline assembly code as never making progress toward termination of a loop.  Consequently, a loop that contains inline assembly will might be reported as an infinite loop</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_pointer_derefs</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report defects where the loop condition involves the dereference of pointers.  When false, loop conditions involving pointers are never reported.

The default value is false. This is a C/C++, Java, and C# option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_no_escape</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report loops that do not have any escape conditions, for example, "while (true) {}".  When the option is false, a loop must have at least one non-trivial escape condition (since otherwise the infinite loop is presumed to be intentional).

The default value is false. This is a C/C++, Java, and C# option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppress_in_macro</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will suppress reporting of potential infinite loops where the control condition is within a macro.

The default value is true. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>INTEGER_OVERFLOW</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>enable_all_overflow_ops</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report defects for subtraction, unary negation, increment, and decrement operations.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_array_sink</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will assume that all array index operations are sinks.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_const_overflows</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will flag overflows due to arithmetic on constant operands that are either literal constants or are known to be specific constant values along a particular path. Occasionally, such overflows may be intentional, but often they indicate a logical error or an erroneous value. Enabling this option flags overflows for the following operators: add, subtract, multiply, truncate due to cast, increment (++), and decrement (--).

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_deref_sink</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will assume that the operation of dereferencing a pointer is a sink.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_return_sink</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will assume that all return statements are sinks.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_tainted_params</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will assume that all operands are potentially tainted.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>INVALIDATE_ITERATOR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>container_type</Name>
            <Type>regex</Type>
            <Description>This option specifies an additional set of types to treat as STL containers.  A type will be considered as a container if its simple identifier (no scope qualifiers) fully (not a substring) matches the specified regular expression, and it has an end() method.

You can specify multiple types by separating them with the '|' regex operator.

The default value is "". This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_map_put</Name>
            <Type>bool</Type>
            <Description>If set to true, the checker reports defects involving Map.put. By default, the checker treats Map.put as though it cannot modify a collection. The default is false. This is a Java-only option.</Description>
            <Languages>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>LOCK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>concurrency (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>LOCK_INVERSION</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>max_lock_depth</Name>
            <Type>int</Type>
            <Description>This option specifies the maximum depth of the call chain that acquires the second lock while the first lock is held.

This option exists because when the lock acquisitions are separated by a  deeply nested call chain, there is often some other synchronization  mechanism involved that the analysis does not understand, so the  resulting reports are often false positives.

The default value is 6. This is a C# and Java option.</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISMATCHED_ITERATOR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>container_type</Name>
            <Type>regex</Type>
            <Description>This option specifies an additional set of types to treat as STL containers.  A type will be considered as a container if its simple identifier (no scope qualifiers) fully (not a substring) matches the specified regular expression, and it has an end() method.

You can specify multiple types by separating them with the '|' regex operator.

The default value is "".</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_comparison</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report when iterators from different containers are compared.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISRA_CAST</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_widening_bool</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will suppress reporting of boolean values cast to wider integer types.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_constant_expressions</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report violations within constant expressions, even though MISRA does not require that.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>non_negative_literals_may_be_unsigned</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker uses an alternate definition of "underlying type".  With the alternate definition, if an integer constant occurs in a context requiring an unsigned type, an integer literal with a non-negative value is considered to have an unsigned underlying type if its value fits into the required type.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_BREAK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allowFallthroughCommentAnywhere</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will recognize a comment that starts anywhere on the last line, not just at the beginning, as the fallthrough acknowledgement comment.

The default value is true. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>anyLineRegex</Name>
            <Type>regex</Type>
            <Description>This option specifies a regular expression for fallthrough acknowledgement comments.  When a comment matching the regular expression is found within a case, it will not be reported, even if it does not end in a break statement.

If it is set to the empty string, then all comments are regarded as NOT matching, so the heuristic is effectively disabled.

The default value is "[^#]fall.?thro?u.". This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>maxCountdownStartVal</Name>
            <Type>int</Type>
            <Description>This option specifies the maximum start case value for recognizing the "countdown" coding idiom.

See the related suppressCountdowns option.

The default value is 16. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>maxReportsPerFunction</Name>
            <Type>int</Type>
            <Description>This option specifies the maximum number of defects to report in a single function.  If the checker would report more than this in a given function, it will instead report none, on the presumption that they are all intentional.

When the value is 0, there is no limit to the number of defects that can be reported by this checker in a single function.

The default value is 5. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressCountdowns</Name>
            <Type>bool</Type>
            <Description>When this option is true, and a "countdown" coding idiom is recognized, the checker will not report a defect.

See the related maxCountdownStartVal option.

The default value is true. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressIfLastComment</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker does not report a defect if the code block for a case ends with a comment.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressIfSimilarASCII</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker does not report defects if a case falls through to another case that has a similar numeric value when interpreted as ASCII. Values are considered similar when both are whitespace values (such as space, tab, or newline), or the two values are different cases (uppercase or lowercase) of the same letter.

The default value is true. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressIfSucceedingAdjacentPair</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker does not report a defect if the case block is immediately followed by two more case lines with no intervening blank lines.

The default value is false. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressOnGuardedBreak</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker does not report defects when the code block for a case includes at least one conditional statement, and at least one of those statements includes a break statement.

The default value is true. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressOnKillpaths</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker does not report defects if the top-level statement in a case is a call to a function that can end the program.

The default value is true. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressOnNextBreak</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker does not report defects if the case that follows the case with the missing break begins with a break statement. 

The default value is true. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressOnSameLine</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker does not report defects if a case starts and ends on the same line (this includes the case of a case that results from a macro expansion).

The default value is true. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressOnTerminatedBranches</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker does not report a defect if there is no path that flows into the succeeding case.

This option only exists to enforce strict coding standards.

The default value is true. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_COMMA</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_COPY_OR_ASSIGN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>rule (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_LOCK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>lock_inference_threshold</Name>
            <Type>float</Type>
            <Description>This option specifies the minimum percentage of accesses to a variable or field that must be protected by a particular lock in order for the checker to conclude that the variable or field should always be protected by that lock.

In C/C++, the default value is 76.

In Java, the default value is 70.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>concurrency (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_RESTORE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_restore_not_dominated_by_modify</Name>
            <Type>bool</Type>
            <Description>By default, the checker only reports cases where the non-local variable is modified along all paths between the point where it is saved and the point where it is restored. Such a modification is said to "dominate" the restoration. While it is clear that the assignment of the local variable to the non-local is genuinely a restoration in such cases, there are also cases that genuinely restore even without such domination. Enabling this option causes such cases to be reported, but is also likely to report some instances where either no genuine restore is occurring or it was intentional to only restore under some conditions. Disabled by default. This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_uncorrelated_with_return</Name>
            <Type>bool</Type>
            <Description>When the restoration of non-local state is not correlated with the return value of the function or method, there is a greater chance that the behavior is intentional. When set to true, this option expands reporting of software  issues to such cases. By default (false), this option otherwise limits reporting to cases in which the checker can both recognize a  pattern in the different return values from the function or method, and establish a correlation between different return values and whether restoration is likely to be expected for any given return value. Default is false (disabled). This is a C/C++ and Java option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_RETURN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>ignore_void</Name>
            <Type>bool</Type>
            <Description>When this option is true and only_one_return is also true, the checker will not report functions whose return type is void.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>only_one_return</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports cases where a function has more than one return statement.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MIXED_ENUMS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_anonymous_enums</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report the mixing of enumeration constants from unnamed (anonymous) enum types with other enum types.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_disjoint_enums</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report the mixing of disjoint enum types.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_equivalent_enums</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report the mixing of different but effectively equivalent enum types.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>NEGATIVE_RETURNS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>NESTING_INDENT_MISMATCH</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_bad_indentation</Name>
            <Type>bool</Type>
            <Description>Enables reporting cases where the syntax is very likely to be correct but the indentation is likely to be incorrect.

This option is enabled automatically for all languages by setting cov-analyze --aggressiveness-level high.  Disabled by default for all languages. This is a C/C++, C#, and Java option. </Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>NO_EFFECT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>array_null</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports a check of an array against NULL.  Checks in macros are not reported.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>bad_memset</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports defects when suspicious arguments are passed to the memset function.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>bool_switch</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports switching on a comparison, as this indicates a likely intended assignment.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>extra_comma</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports a defect if the left operand of a comma operator has no side effects.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>incomplete_delete</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports a defect for the pattern "delete a, b".  In that pattern, only the first pointer is freed.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>no_effect_deref</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports useless dereferences of pointers.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>no_effect_test</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports useless boolean tests. The programmer probably intended to assign rather than compare the arguments.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>self_assign</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports assignments of fields and globals to themselves.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>self_assign_in_macro</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports self assigns where the right-hand side is in a macro.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>self_assign_to_local</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports assignments of locals and parameters to themselves.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>static_through_instance</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will NOT report cases where a static field or method is accessed using an instance pointer.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>unsigned_compare</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports the comparison of an unsigned quantity against 0 where the result is always the same.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>unsigned_compare_macros</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports the comparison of an unsigned quantity against 0 in macros.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>unsigned_enums</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports the comparison of an enum value against 0 as a defect when the enum's underlying type is unsigned and the result is always the same.

Note that the underlying type of an enum is, in part, defined by the compiler implementation.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>NON_STATIC_GUARDING_STATIC</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>NULL_RETURNS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_unimpl</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports dangerous calls even when the implementation of the callee is not available to the analysis.  In that case, the fact that a call is dangerous is inferred from how the function's return value is normally handled by the code base.

The default value is false. This is a C/C++ and C# option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>stat_bias</Name>
            <Type>float</Type>
            <Description>This option sets the number that is added to the "checked" count to bias the checker in favor of reporting defects.

In C/C++, the default value is 0.

In Java, the default value is 3. This is a C/C++, Java, and C# option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>stat_threshold</Name>
            <Type>float</Type>
            <Description>This option sets the percentage of call sites that must have their value checked in order for the statistical analysis to conclude that the function should always have its return value checked.

The default value is 80. This is a C/C++, Java, and C# option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppress_under_related_conditional</Name>
            <Type>bool</Type>
            <Description>Suppresses defect reports that are heuristically identified as being controlled by a condition that is related to the call alleged as returning null. When set, this reduces false positive defect reports of the pattern: if (&lt;something guaranteeing foo(x) returns non-null&gt;) dereference(foo(x));

 Option is enabled by default for C#. It is disabled by default for C/C++ and Java.  </Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>OPEN_ARGS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ORDER_REVERSAL</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>max_lock_depth</Name>
            <Type>int</Type>
            <Description>This option specifies the maximum depth of the call chain that acquires the second lock while the first lock is held.

This option exists because when the lock acquisitions are separated by a  deeply nested call chain, there is often some other synchronization  mechanism involved that the analysis does not understand, so the  resulting reports are often false positives.

The default value is 6.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>concurrency (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>OVERFLOW_BEFORE_WIDEN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>check_macros</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report potentially overflowing operations even when they occur within macros.

This option is enabled automatically for C/C++ by setting cov-analyze --aggressiveness-level medium. The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_nonlocals</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report potentially overflowing operations when the existing widening operation is non-local, for example an implicit conversion in a function call or assignment to a global variable.

This option is enabled automatically for all languages by setting cov-analyze --aggressiveness-level medium. The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_types</Name>
            <Type>regex</Type>
            <Description>This option specifies a regular expression (Perl syntax) to match against the destination type of the existing widening operation.  A defect will only be reported if the destination type matches the specified regular expression.

This option is enabled automatically for C/C++ by setting cov-analyze --aggressiveness-level high. The default value is "(?:unsigned )?long long|.*64.*". This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>ignore_types</Name>
            <Type>regex</Type>
            <Description>This option specifies a regular expression (Perl syntax) to match against the destination type of the existing widening operation. A defect will NOT be reported if the destination type matches the specified regular expression, even if it matches the check_types regular expression.

This option is enabled automatically for C/C++ by setting cov-analyze --aggressiveness-level high. The default value is "s?size_t|off_t|time_t|__off64_t|ulong|.*32.*". This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>OVERRUN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_cond_call_on_parm</Name>
            <Type>bool</Type>
            <Description>When this option is true, inside callees, the checker will report cases where a buffer parameter is indexed by another parameter despite the index being passed to a function in a conditional which could potentially check its range.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_range_check_on_parm</Name>
            <Type>bool</Type>
            <Description>When this option is true, inside callees, the checker will report defects when a buffer parameter is indexed by another parameter, even though the index has been previously range-checked against some variable (for example, a global).

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_strlen</Name>
            <Type>bool</Type>
            <Description>When this option is true, allocation size expressions involving strlen will be evaluated by examining the strlen argument.  When it is false, such expressions are considered to have an unknown value.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_symbol</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker uses symbolic analysis to find array overruns, even when the size of the array is determined at run time.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_nonsymbolic_dynamic</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report overruns of arrays that are dynamically allocated but with fixed allocation sizes.  These reports have a high false positive rate because the analysis often can't figure out the proper correlation between allocation sites and array accesses in code that uses this technique.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_underrun</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports when an array is accessed with a negative index.

This option is enabled by setting the --aggressiveness-level option of cov-analyze to medium (or to high). The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>strict_arithmetic</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports when pointer arithmetic yields an address that is before the first byte or after the last byte+1 of the buffer. Using this address as a loop bound will typically result in an overrun or underrun.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>strict_member_boundaries</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports when adjacent arrays within a struct are used as a single large array (the C language does not guarantee that this is safe).

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>OVERRUN_DYNAMIC</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_cond_call_on_parm</Name>
            <Type>bool</Type>
            <Description>When this option is true, inside callees, the checker will report cases where a buffer parameter is indexed by another parameter despite the index being passed to a function in a conditional which could potentially check its range.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_range_check_on_parm</Name>
            <Type>bool</Type>
            <Description>When this option is true, inside callees, the checker will report defects when a buffer parameter is indexed by another parameter, even though the index has been previously range-checked against some variable (for example, a global).

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_strlen</Name>
            <Type>bool</Type>
            <Description>When this option is true, allocation size expressions involving strlen will be evaluated by examining the strlen argument.  When it is false, such expressions are considered to have an unknown value.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_symbol</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker uses symbolic analysis to find array overruns, even when the size of the array is determined at run time.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEPRECATED (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>OVERRUN_STATIC</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_cond_call_on_parm</Name>
            <Type>bool</Type>
            <Description>When this option is true, inside callees, the checker will report cases where a buffer parameter is indexed by another parameter despite the index being passed to a function in a conditional which could potentially check its range.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_range_check_on_parm</Name>
            <Type>bool</Type>
            <Description>When this option is true, inside callees, the checker will report defects when a buffer parameter is indexed by another parameter, even though the index has been previously range-checked against some variable (for example, a global).

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEPRECATED (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>PARSE_ERROR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>PARSE_WARNINGS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>PASS_BY_VALUE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>catch_threshold</Name>
            <Type>int</Type>
            <Description>This option specifies the maximum size of a catch parameter.  When a catch parameter is larger, a defect is reported.

The default value is 64.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>size_threshold</Name>
            <Type>int</Type>
            <Description>This option specifies the maximum size of a function parameter.  When a parameter is larger, a defect will be reported.

The default value is 128.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>unmodified_threshold</Name>
            <Type>int</Type>
            <Description>This option specifies the maximum size of a function parameter that is not modified inside the function.  When an unmodified parameter is larger, a defect will be reported.

The default value is 128.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>READLINK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>RESOURCE_LEAK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_address_taken</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will track report a leak even the resource pointer has its address taken.

The checker does not keep track of what happens to the pointer's address, so those reports have a high chance of being false positives, since the code could free the resource through the taken address later on.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_aliasing</Name>
            <Type>bool</Type>
            <Description>When this option is true and track_fields is true, the checker will report a resource leak for fields of potentially aliased pointers (for example, parameters) if the pointers are freed.

Setting this to true might find more defects, but it can also cause the analysis to slow down and report more false positives.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_cast_to_int</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report a leak even if the resource pointer was at some point cast to an integer.

The checker does not keep track of what happens to such integers, so those reports have a high chance of being false positives, since the code could cast the integer back to a pointer later on.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_constructor</Name>
            <Type>bool</Type>
            <Description>When this option is true and allow_unimpl is true, the checker will assume that constructors do not alias arguments.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_main</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report a resource leak in a function called "main".

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_overwrite_model</Name>
            <Type>bool</Type>
            <Description>When this option is true and track_fields is true, the checker will report a resource leak if a field that refers to a resource is overwritten in a function call.

Setting this to true might find more defects, but it can also cause the analysis to slow down and report more false positives.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_template</Name>
            <Type>bool</Type>
            <Description>When this option is true and allow_unimpl is true, the checker will assume that template functions do not alias arguments.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_unimpl</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will assume that functions whose implementation is not available to the analysis do not alias (save) or free their arguments.

Setting this to true will usually cause a lot of false positives to be reported.  However, you can use the FPs to figure out which functions need to have free models written.  Once the free models are written, what is left will be additional real bugs that would not otherwise be found.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_virtual</Name>
            <Type>bool</Type>
            <Description>When this option is true and allow_unimpl is true, the checker will assume that virtual calls do not alias or free their arguments.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>no_vararg_leak</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will not report a resource leak if a pointer is passed to a variadic function (a function that can take different numbers of arguments).

You may want to set this to true if you have a variadic function that frees or aliases its parameters, and are seeing false positives as a result.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_handles</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report leaks of non-pointer "handles," in addition to memory leaks.

The default value is true. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>track_fields</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will track structure fields and report resource leaks involving resources referred to by them.

Setting this to true might find more defects, but it can also cause the analysis to slow down and report more false positives.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>RETURN_LOCAL</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>REVERSE_INULL</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>REVERSE_NEGATIVE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SECURE_CODING</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SECURE_TEMP</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SELF_ASSIGN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>rule (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SIGN_EXTENSION</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>require_unsigned_dest</Name>
            <Type>bool</Type>
            <Description>When this option is true, the result type of the sign-extending cast must be unsigned in order to be reported as a defect.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SIZECHECK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>ampersand_in_size</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports defects where the memory allocated is calculated using the bitwise AND operator (&amp;) and two quantities.  That can happen when &amp; (ampersand) is typed but * (asterisk) was meant.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>improper_new</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports defects where the 'new' operator is used to allocate one element with a particular initial value, but it appears that the programmer intended to allocate an array of a particular size.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>incorrect_multiplication</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports defects where the memory allocated is calculated using a multiple of a constant that is not the same size as the pointer's target type.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEPRECATED (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SIZEOF_MISMATCH</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>strict_memcpy</Name>
            <Type>bool</Type>
            <Description>If set to true, reports a defect for a mismatch between the function arguments of memcpy(dest, src, n). The mismatch can occur between n and dest or between n and src. By default, this option is disabled (false). Enable it by setting it explicitly to true or by setting cov-analyze --aggressiveness-level medium.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SLEEP</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>concurrency (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STACK_USE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>alignment_bytes</Name>
            <Type>int</Type>
            <Description>This option specifies the minimum allocation alignment for objects on the stack.  All stack allocations are promoted to a multiple of this boundary.  It must be a power of two (1 is allowed).

The prologue usage is also promoted to the nearest multiple of the alignment boundary if not explicitly specified.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>max_single_base_use_bytes</Name>
            <Type>int</Type>
            <Description>This option specifies the maximum number of bytes allowed for a single stack allocation before it that allocation, by itself, will be reported as a defect.

The default value is 10000.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>max_total_use_bytes</Name>
            <Type>int</Type>
            <Description>This option specifies the maximum number of bytes allowed for total stack allocation before that aggregate allocation is reported as a defect.

The default value is 250000.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>note_direct_recursion</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports a defect whenever it sees a function that directly calls itself.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>note_indirect_recursion</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports a defect whenever it sees a function that indirectly calls itself.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>note_indirection</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports a defect when a function call through indirection (function pointers) is seen.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>note_max_use</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports a defect for the function with highest stack usage in the code base.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>prologue_use_bytes</Name>
            <Type>int</Type>
            <Description>This option specifies the amount of stack usage added to any function that has any other stack usage.  It must be zero or a power of two that is a multiple of the alignment boundary.

The default value is 16.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>reuse_stack</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker assumes that stack space is reused by non-overlapping scopes.  Whether that is true or not depends on the compiler and the optimization settings.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STRAY_SEMICOLON</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STREAM_FORMAT_STATE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_suspicious_setf_args</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report cases where it does not understand the mask that is passed to setf.  In those cases, the checker is unable to determine if the code is correct.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>saver_class_regex</Name>
            <Type>regex</Type>
            <Description>This option specifies a regular expression that matches a class name. The checker will not report any unsaved settings for a stream that is passed as the first argument of a constructor for a class whose simple identifier (no qualifiers) matches (including substring match) this regular expression.

The purpose of this option is to handle cases where the formatting flags are saved in a stack-allocated object that restores those flags in its destructor.

The default value is "saver$".</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STRING_NULL</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STRING_OVERFLOW</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_fixed_size_dest</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports defects when the destination size is known, but the source size is not.  When it is false, defects are not reported unless both source and destination sizes are known.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STRING_SIZE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SWAPPED_ARGUMENTS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>TAINTED_SCALAR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>tainting_byteswaps</Name>
            <Type>bool</Type>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>TAINTED_STRING</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>paranoid_format</Name>
            <Type>bool</Type>
            <Description>Reports a defect when a non-constant string is used as a format string argument. This option addresses the case where Coverity Analysis does not track the propagation of tainted string, which typically occurs once the string flows through a global variable. For a format string vulnerability, adding a correct format specifier (usually "%s") as the format string argument usually alleviates the problem.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>TOCTOU</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNCAUGHT_EXCEPT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>except_ignore</Name>
            <Type>regex</Type>
            <Description>This option specifies a regular expression to be matched (including as a  substring) against the simple identifier (no scope qualifiers) of the  exception class name.  An exception with class type that matches this  regular expression will not be reported.

The default value is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>except_report</Name>
            <Type>regex</Type>
            <Description>This option specifies a regular expression to be matched (including as a  substring) against the simple identifier (no scope qualifiers) of the  exception class name.  If this option is set, then only exceptions with class type that matches this regular expression will be reported.

The except_ignore option takes precedence over the except_report option.

The default value is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>follow_indirect_calls</Name>
            <Type>bool</Type>
            <Description>When this option is true, and either virtual function call tracking  and/or function pointer tracking are enabled, UNCAUGHT_EXCEPT will  follow such indirect calls for the purpose of propagating thrown  exceptions. When false, exceptions are not considered to propagate  across indirect calls, even when indirect call tracking is otherwise  enabled.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>fun_ignore</Name>
            <Type>regex</Type>
            <Description>This option specifies a regular expression to be matched (including as a  substring) against the simple identifier (no scope qualifiers) of the  root function from which an exception escapes.  Uncaught exceptions escaping out of a function that matches will not be reported.

The default value is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>fun_report</Name>
            <Type>regex</Type>
            <Description>This option specifies a regular expression to be matched (including as a  substring) against the simple identifier (no scope qualifiers) of the  root function from which an exception escapes.  If this option is set, then the checker will report when exceptions escape from functions that match the regular expression, and only those functions</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_all_fun</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report uncaught exceptions  escaping from any root function, regardless of its name.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_exn_spec</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report violations of exception specifications.

The default value is true.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_thrown_pointers</Name>
            <Type>bool</Type>
            <Description>If set to true, reports an error when any pointer is thrown. In C++, throwing by value is recommended, while throwing by pointer discouraged. Default is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNINIT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_unimpl</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker assumes that a function whose implementation is not available to the analysis does not do any initialization.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_arguments</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports a defect if the arguments to any function are uninitialized.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_malloc_wrappers</Name>
            <Type>bool</Type>
            <Description>By default, UNINIT tracks dynamic memory allocated with calls to malloc() or new, but it does not track memory allocated by wrappers around malloc() or new.

When this option is true, the checker tracks this memory and reports defects if it is used without initialization. However, a higher rate of false positives can occur because UNINIT cannot identify the memory that these wrappers or allocating functions have allocated and initialized.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_mayreads</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports defects on fields of structures that are only read along some paths in a called function. When it is false, the field must be read on all paths to be reported.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_deep_read_models</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker does a deeper interprocedural analysis--it tracks variable uses at callee depths greater than 1. This can increase the number of reported defects but can also result in more false positives because of inadequacies in tracking interprocedural contexts.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_parm_context_reads</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports defects on uninitialized fields of structures within callees that are conditioned on constraints on other parameter values.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_write_context</Name>
            <Type>bool</Type>
            <Description>By default, UNINIT does not distinguish the interprocedural context under which a callee can initialize a parameter or parameter field. To avoid too many false positives, UNINIT does not report a defect if it finds an initialization of a parameter along at least one path in the callee. This option relaxes this restriction and tracks the context of interprocedural initializations. The checker reports more defects and possibly more false positives because of approximations in interprocedural context tracking.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNINIT_CTOR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>ctor_func</Name>
            <Type>string_list</Type>
            <Description>This option specifies a set of method names, as simple identifiers (no  scope qualifiers, no parameter types), to treat as if they were  constructors.  If a class has at least one method with a name in this  set, then the methods with such names are checked to make sure they  initialize all members (regardless of the ignore_empty_constructors and  ignore_priv_prot_constructors options), and the actual constructors are  not checked.

This option is useful when the code base contains some classes that have  a dedicated "init" or similar method that plays the role of a  constructor, and the actual constructor does nothing.

The default value is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>ignore_array_members</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will ignore array fields that are  not initialized in the constructor.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>ignore_empty_constructors</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will ignore (not report defects  in) empty constructors.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>ignore_priv_prot_constructors</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will ignore (not report defects  in) private and protected constructors.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_compiler_bugs</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will report when a member should be value-initialized according to the C++ language rules, but some compilers will leave it uninitialized due to bugs on those compilers. When the option is false, the checker will not report them.  When it is unset, the checker will report such members if the native compiler appears to be a version that has the bug, as determined when the compiler was configured by cov-configure or cov-build.

The default is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_scalar_arrays</Name>
            <Type>bool</Type>
            <Description>Turns on tracking of scalar 1-dimensional (1-D) arrays. Aggressiveness levels of medium and above also turn on tracking of these arrays. Note that 2-D arrays are never tracked.

Disabled by default.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNREACHABLE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_unreachable_empty_increment</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker reports defects when a loop increment is unreachable and the loop body does not execute more than once.

The default value is true for C/C++ and false for Java and C#. This option is automatically  is set to true (enabled) for C# and Java when cov-analyze --agressiveness-level medium.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_unreachable_in_macro</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports defects when a code block is unreachable due to a macro expansion.

The default value is false. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNUSED_VALUE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>USE_AFTER_FREE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_report_args</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports a defect when a freed pointer is passed to any function.  When it is false, passing a freed pointer results in a defect report only if the analysis can deduce that the function frees or dereferences it.

The default value is true. This is a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_simple_use</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker reports a defect when a freed pointer value is used in any way.  When it is false, the checker will only report errors when freed pointers are dereferenced or used as function arguments.

The default value is true. This a C/C++ option.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>USER_POINTER</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>VARARGS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>VIRTUAL_DTOR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>ignore_empty_dtors</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will treat an empty destructor the  same as an implicitly defined destructor.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>VOLATILE_ATOMICITY</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>WRAPPER_ESCAPE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>escape_locals_only</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will only report defects when the  internal representation escapes from a stack-allocated object.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>skip_AddRef_callers</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker will not report a defect in any  function that calls the AddRef() method.  This option exists to work  around false positives caused when the checker fails to understand a  reference counting idiom.

The default value is false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
    </Checkers>
  </AnalysisBuildSettings>
  <CentralAnalysisEnabled>false</CentralAnalysisEnabled>
  <StripPaths>
    <RemoteStripPaths />
    <LocalStripPaths />
  </StripPaths>
  <LocalAnalysisCores>1</LocalAnalysisCores>
  <UseGlobalRemoteSettings>true</UseGlobalRemoteSettings>
  <SolutionFiles />
  <UseSolutionBuildSettings>false</UseSolutionBuildSettings>
  <BuildSettingsOverridenFirstTime>false</BuildSettingsOverridenFirstTime>
</Coverity.Prevent.Desktop.Configuration>